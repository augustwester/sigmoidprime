<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>sigmoid prime: approachable machine learning</title>
    <meta name="description" content="Striving for intuitive explanations of machine learning algorithms.">
    <meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport">
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:creator" content="@wster">
    <meta name="twitter:title" content="How to Build (and Understand) a Neural Network Pt. 1: The Perceptron">
    <meta name="twitter:description" content="A beginner's introduction to the perceptron learning algorithm.">
    <meta name="twitter:image" content="http://sigmoidprime.com//assets/posts/1/thumb.png">

    <link rel="stylesheet" href="/css/style.css">
    <link rel="stylesheet" href="/libs/highlight/styles/atom-one-light.css">
    <link rel="stylesheet" href="/libs/katex/katex.min.css">
    <link rel="stylesheet" href="/libs/c3/c3.min.css">

    <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/assets/favicons/apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/favicons/apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/favicons/apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/favicons/apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon-precomposed" sizes="60x60" href="/assets/favicons/apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/assets/favicons/apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/assets/favicons/apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/assets/favicons/apple-touch-icon-152x152.png">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon-196x196.png" sizes="196x196">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon-32x32.png" sizes="32x32">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="/assets/favicons/favicon-128.png" sizes="128x128">

    <script src="/libs/highlight/highlight.pack.js"></script>
    <script src="/libs/katex/katex.min.js"></script>
    <script src="/libs/katex/contrib/auto-render.js"></script>
    <script src="/libs/d3/d3.v3.min.js"></script>
    <script src="/libs/c3/c3.min.js"></script>
    <script src="/libs/function-plot/function-plot.js"></script>
    <script src="/libs/svgjs/svg.min.js"></script>
    <script>hljs.initHighlightingOnLoad();</script>
  </head>
  <body>
    <header class="top-header">
      <div class="inner-header">
        <div class="logo-container">
          <a href="/"><span class="logo">sigmoid<span class="prime">′</span></span></a>
          <span class="tagline">approachable machine learning.</span>
        </div>
      </div>
    </header>
    <main style="margin-top:80px;">
      <div class="article-container ">
        <article>
          <header>
            <h1 class="post-title">How to Build (and Understand) a Neural Network Pt. 1: The Perceptron</h1>
          </header>
          <div class="date-ct">
            <p>30 December 2016</p>
          </div>
          
<p>Building a neural network is fairly easy. It doesn’t require you to know any obscure programming language, and you can build a working model with surprisingly few lines of code. To understand how it works however — to <em>really</em> understand it — takes mathematical insight more than anything else. While this may sound lofty, anyone with a firm grasp of high school level math is equipped to take on the task.</p>

<p>This is the first in a series of posts that will culminate in us building a neural network in Python. It will be a rudimentary one, but at the end, we will have covered all of the concepts that make it tick. Hopefully, this will set us both on a path to deepen our knowledge of how to make machines smart.</p>

<p>A good place for us to start is the <a href="https://en.wikipedia.org/wiki/Perceptron">perceptron algorithm</a>. According to Wikipedia:</p>

<blockquote>
  <p><em>The perceptron algorithm dates back to the late 1950s; its first implementation, in custom hardware, was one of the first artificial neural networks to be produced.</em></p>
</blockquote>

<p>Perceptrons are a good place to start because they showcase the power and versatility of learning algorithms while remaining very simple. Once we are comfortable with perceptrons, we can use this as a springboard to tackle some of the more sophisticated concepts in machine learning.</p>

<p>We’ll start off with some overall theory, followed by an introduction to the actual algorithm. Finally, we’ll code a  working perceptron in Python.</p>

<h2 id="overall-theory">Overall theory</h2>

<p>The perceptron algorithm is a <strong>binary classification algorithm</strong>, which is to say that it can tell whether a piece of data belongs to one of two classes. To get a better sense of what this means, let’s take a look at the following plot:</p>

<div id="versicolorsetosa" class="scatter-plot"></div>
<script type="text/javascript" src="/js/versicolorsetosa.js"></script>

<p>This is a scatter plot of part of the <a href="https://archive.ics.uci.edu/ml/datasets/Iris">Iris dataset</a>; the de facto dataset for training a perceptron. The full dataset contains 150 samples of three different types of Iris flower (50 samples of each type). Each sample contains four features: sepal width, sepal length, petal width, and petal length. In the scatter plot above, we are only looking at two features (petal width and petal length) for two types of Iris (setosa and versicolor).</p>

<p>The thing to notice about the data is that it is linearly separable. In other words, the points belonging to each Iris type are clustered in such a way that you can separate them with a straight line. What the perceptron algorithm does is it automatically ‘learns’ the parameters for a model (in this case a linear function) that, when presented with the features of a sample, returns a positive number for one Iris type, and a negative number for the other. This enables us to classify a sample as belonging to the setosa family or the versicolor family solely by looking at the features of the flower.</p>

<p>The following steps outline how to create a model with this capability.</p>

<ol>
  <li>We initialize a number of <strong>parameters</strong> with random values between 0 and 1. If each of our samples has €n€ features, we initialize €n+1€ parameters. Out of these €n+1€ parameters,  there will be €n€ <strong>weights</strong>, and one so-called <strong>bias</strong>. There will <em>always</em> be an equal number of weights and features. I will get to the point of the parameters in a minute, but for the moment, you can think of them as the knobs and dials of our model, which our algorithm uses to improve its performance.</li>
  <li>Having initialized our parameters, we now feed <strong>training data</strong> to our (currently random, and thus highly inaccurate) model one sample at a time. The model takes the features of a sample as input, and multiplies each feature by the model’s corresponding weight. This yields our <strong>weighted features</strong>.</li>
  <li>Next, we calculate the sum of the weighted features and add the bias. At this point, all we are left with is a number. If this number is less than zero, we classify the sample as belonging to the setosa family; if the number is greater than zero, we classify the sample as being of type versicolor.</li>
  <li>Last but not least, if our prediction is wrong, we update our parameters. If our prediction is right, we do nothing, and move on to the next sample.</li>
</ol>

<p>This last step tells us that what we are dealing with here is <strong>supervised learning</strong>. The reason it is “supervised” is that we already know the right answer — aka. the “label” — for every sample. The label will either be 0 or 1, respectively representing setosa and versicolor. Knowing the right answer lets us adjust the parameters of our model every time it performs poorly. That way, looping over each sample will incrementally improve its accuracy.</p>

<h2 id="the-math">The math</h2>

<p><img src="/assets/posts/1/linear-separation.gif" /></p>

<p>The animation above illustrates an example of a 2D plane separating setosa and versicolor points in 3D space. Our parameters define the plane — also known as the <strong>decision boundary</strong> — and when these are multiplied by the coordinates of a point (the features), the result will be positive if the point is located above the plane, and negative when located below the plane. This is the core idea that makes our algorithm possible. Our job is to find a set of parameters that separate the classes perfectly (like the one above).</p>

<p>The four features of every sample will be represented by a four-dimensional vector €x€. The vector €\theta€ will be a four-dimensional vector containing the weights. If €b€ is the bias, we can mathematically represent our model like this:</p>

<p>€€
\theta_1x_1 + \theta_2x_2 + \theta_3x_3 + \theta_4x_4 + b
€€</p>

<p>With four coordinates (€x_1€ to €x_4€), this expression defines a cube in 4D space rather than a plane in 3D space like the one shown in the animation. Impossible to visualize, yes, but that doesn’t change a thing. Pretty cool, right?</p>

<p><em>A brief note about terminology: We can refer to a line in 2D space, a plane in 3D space, a cube in 4D space, and so on by the same name: hyperplane. More generally, a hyperplane is simply a space of dimension €n-1€ in an enclosing space of dimension €n€. As we will see, this will be a convenient term as we expand our algorithms to higher dimensions.</em></p>

<p>It is worth repeating that – for 3D space – when this expression is positive, the point €x€ is located above the plane, and when the expression is negative, €x€ is located beneath the plane. The plane itself is defined by the parameters €\theta€ and €b€, where €\theta€ is responsible for “tilting” the plane, and €b€ either pushes or pulls the plane up or down in the coordinate space. Note that all of this holds true for higher dimensional hyperplanes as well.</p>

<p>Keep in mind that our weights and features are represented as vectors. This allows us to rewrite the above expression by taking the <a href="https://www.youtube.com/watch?v=WNuIhXo39_k">dot product</a> of €x€ and €\theta€, and then adding €b€ to the resulting scalar:</p>

<p>€€
(x \cdot \theta) + b
€€</p>

<p>To make things even more concise, we will add another element €x_0€ to our vector €x€ and make sure that it is always equal to 1. We will also add a corresponding weight €\theta_0€ to our vector €\theta€. This allows us to treat the bias (now represented as €\theta_0€) as part of our vector operations, so we can simplify the above expression even further:</p>

<p>€€
x \cdot \theta
€€</p>

<p>Spelled out, this is now equal to:</p>

<p>€€
\begin{Bmatrix}1 \cr x_1 \cr x_2\cr x_3 \cr x_4 \end{Bmatrix}
\cdot
\begin{Bmatrix}\theta_0 \cr \theta_1 \cr \theta_2 \cr \theta_3 \cr \theta_4\end{Bmatrix} = \theta_0 + \theta_1x_1 + \cdots + \theta_4x_4
€€</p>

<p>All of this may seem like mere mathematical housekeeping, but as we will see, it will keep our code neat and tidy, and — much more importantly — it will allow us to vectorize our computations. Vectorization is important, since it enables significant computational speedups, as soon as we begin to handle more complex models with larger amounts of data. (For a small dataset like ours, it won’t really make a difference, but it is good practice to keep it in mind.)</p>

<p>We will now define a function known as the <a href="https://en.wikipedia.org/wiki/Heaviside_step_function">heaviside step function</a> or unit step function:</p>

<p>€€
\sigma(z)=\begin{cases} 1 &amp; {\small z &gt; 0,} \cr 0 &amp; \text{otherwise} \end{cases}
€€</p>

<p>If it isn’t immediately obvious from this definition, the heaviside step function takes a scalar input €z€ and returns 1 if €z€ is positive, and 0 if €z€ is nonpositive. The sole purpose of the heaviside step function is to classify points below the decision boundary as 0, and points above the decision boundary as 1. The output will thus be our prediction of the Iris type.</p>

<p>For each sample, the output €\hat{y}€ of our model will be:</p>

<p>€€
\hat{y} = \sigma(x \cdot \theta)
€€</p>

<p>Now to the most important part. In order for the network to ‘learn’ a  function — which is to say a bias and a set of weights — that produces a plane which separates setosa and versicolor points, we will need a <strong>learning algorithm</strong>. Fortunately, the perceptron learning algorithm is super simple:</p>

<p>€€
\Delta \theta_i = (y^{(j)} - \hat{y}^{(j)})x_i^{(j)}
€€</p>

<p class="subtext">€j€ represents the €j€th sample, and €i€ represents the €i€th feature. €y^{(j)}€ is the true label.</p>

<p>If you are not used to mathematical notation, this may seem a little intimidating. Not to worry; it is easy to see what is happening here by looking at an example.</p>

<p>Let’s assume that, during training, the model erroneously interprets setosa features for versicolor features. The heaviside step function would then output a 1 when it should have given us a 0. In this case, €\Delta \theta_i€ would be:</p>

<p>€€
\Delta \theta_i = (0 - 1)x_i^{(j)}
€€</p>

<p>If €x_i^{(j)}€ were, say, the petal length of our misclassified sample with a value of 1.9, the equation would look like this:</p>

<p>€€
\Delta \theta_i = (-1) \cdot 1.9 = -1.9
€€</p>

<p>We would then subtract 1.9 from €\theta_i€’s current value.</p>

<p>To see why we subtract, remember that the output of the model was 1 when it should have been 0. This means that the result of the dot product €(x \cdot \theta)€ was positive when it should have been negative, and therefore that the parameters are currently adjusted too high. Had we predicted a 0 when the true label was 1, the value of €\theta_i€ would have been increased by 1.9.</p>

<p>This same learning algorithm holds for the bias. However, since the bias’ corresponding “feature” is 1, this leaves us with:</p>

<p>€€
\Delta \theta_0 = (y^{(j)} - \hat{y}^{(j)})
€€</p>

<p>And that’s it!</p>

<p>A cool thing about the perceptron algorithm is that it is guaranteed to find exactly the right parameters that separate the two classes at 100% accuracy (granted that the data is linearly separable of course). The question is whether these parameters generalize and enable the model to correctly predict the classes of samples that weren’t in the training set.</p>

<h2 id="getting-our-hands-dirty">Getting our hands dirty</h2>

<p>To start off, make sure that you have Python and <a href="http://www.numpy.org/">NumPy</a> installed on your machine. If you are not already familiar with NumPy, it is an essential package for Python for doing matrix and vector operations. There will be tons of these going forward.</p>

<p>To import and handle the Iris dataset, we will use <a href="http://pandas.pydata.org">Pandas</a>. NumPy as well as Pandas can be installed by running <code class="highlighter-rouge">pip3 install numpy</code> and <code class="highlighter-rouge">pip3 install pandas</code> in the command line. Once you’ve got everything set up, we’ll create a new Python file and do the requisite imports at the top. We will also be including the Iris dataset made available from <a href="https://archive.ics.uci.edu/ml/datasets/Iris">UCI’s website</a>. As a courtesy, you may want to download the file and reference it locally in order to spare UCI of unnecessary traffic.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">pandas</span> <span class="kn">as</span> <span class="nn">pd</span>

<span class="n">dataset</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">"https://archive.ics.uci.edu/ml/machine-learning-databases/iris/iris.data"</span><span class="p">)</span>

<span class="c"># Combining half the setosa features and half the versicolor features into our training dataset</span>
<span class="n">train_features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">25</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">75</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">train_targets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">25</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">50</span><span class="p">:</span><span class="mi">75</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c"># Combining the remaining setosa and versicolor features into the test dataset</span>
<span class="n">test_features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">25</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">75</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">test_targets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">25</span><span class="p">:</span><span class="mi">50</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">dataset</span><span class="o">.</span><span class="n">iloc</span><span class="p">[</span><span class="mi">75</span><span class="p">:</span><span class="mi">100</span><span class="p">,</span> <span class="mi">4</span><span class="p">]</span><span class="o">.</span><span class="n">values</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

<span class="c"># Appending 1 as the first feature of each sample, so theta0 can act as the bias</span>
<span class="n">train_features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">train_targets</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">train_features</span><span class="p">]</span>
<span class="n">test_features</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">test_targets</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">test_features</span><span class="p">]</span>

<span class="c"># Changing the name of the two flower types into our target values 0 and 1</span>
<span class="n">train_targets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">train_targets</span> <span class="o">==</span> <span class="s">"Iris-setosa"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">test_targets</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">test_targets</span> <span class="o">==</span> <span class="s">"Iris-setosa"</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

<span class="c"># Converting the target arrays from 50x1 matrices to 50D vectors</span>
<span class="n">train_targets</span> <span class="o">=</span> <span class="n">train_targets</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">50</span><span class="p">))</span>
<span class="n">test_targets</span> <span class="o">=</span> <span class="n">test_targets</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="mi">50</span><span class="p">))</span></code></pre></figure>

<p>I hope the comments make it clear what is going on here.</p>

<p>We will use the training samples to train the model, and our test samples to verify whether the model generalizes and correctly predicts the classes of unseen samples. A 50/50 split between training and test samples is not very common (usually it is 60/40 or 70/30 with the majority going to the training samples), but it should suffice for this example.</p>

<p>Note that all training samples are now stored within a 50x5 matrix €X€. If you are unfamiliar with matrices, they can simply be thought of as containers of multiple vectors. Thus, the 50x5 matrix contains 50 samples/vectors, and each of those vectors contains four features <em>and</em> a bias. In other words, our matrix €X€ contains 50 €x€s.</p>

<p>Now that we have our data organized and ready, it is time to code the actual perceptron. Let’s start by creating a <code class="highlighter-rouge">Perceptron</code> class with a <code class="highlighter-rouge">fit</code> method that takes three parameters: <code class="highlighter-rouge">X</code>, <code class="highlighter-rouge">y</code> and <code class="highlighter-rouge">epochs</code>. <code class="highlighter-rouge">X</code> will be our matrix of features, <code class="highlighter-rouge">y</code> will be a vector containing the corresponding target values, and <code class="highlighter-rouge">epochs</code> will be an integer specifying how many times to loop over the training data. If we didn’t specify the number of epochs, we would only have 50 iterations to update our parameters, which probably wouldn’t be enough for them to converge on the most optimal values.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">class</span> <span class="nc">Perceptron</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Perceptron</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">5</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">X</span><span class="p">)):</span>
                <span class="n">weighted_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
                <span class="n">y_hat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">heaviside_step</span><span class="p">(</span><span class="n">weighted_input</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">multiply</span><span class="p">((</span><span class="n">y</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">y_hat</span><span class="p">),</span> <span class="n">X</span><span class="p">[</span><span class="n">i</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">heaviside_step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">weighted_input</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">weighted_input</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span></code></pre></figure>

<p>Believe it or not, this is the whole perceptron algorithm!</p>

<p>We start by initializing five random weights between 0 and 1. Then, the <code class="highlighter-rouge">fit</code> method loops over all samples <code class="highlighter-rouge">epochs</code> number of times. In the inner-most loop, we take the dot product between every feature vector <code class="highlighter-rouge">X[i]</code> and the parameter vector <code class="highlighter-rouge">self.theta</code>. The result of the dot product is handed over to the heaviside step function yielding our <code class="highlighter-rouge">y_hat</code>, and the parameters are then updated.</p>

<p>To benchmark how well our model performs, we will add a <code class="highlighter-rouge">predict</code> method to our class that uses the learned parameters <code class="highlighter-rouge">self.theta</code> to predict the classes of our test samples:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">predict</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    <span class="n">weighted_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">heaviside_step</span><span class="p">(</span><span class="n">weighted_input</span><span class="p">)</span></code></pre></figure>

<p>All there is left to do is feed some data to a <code class="highlighter-rouge">Perceptron</code> object:</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c"># Initializing a Perceptron object and feeding it our training data</span>
<span class="n">pcpt</span> <span class="o">=</span> <span class="n">Perceptron</span><span class="p">()</span>
<span class="n">pcpt</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">train_features</span><span class="p">,</span> <span class="n">train_targets</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>

<span class="c"># The model has now been trained. Time to benchmark!</span>
<span class="n">est</span> <span class="o">=</span> <span class="n">pcpt</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">test_features</span><span class="p">)</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">est</span> <span class="o">-</span> <span class="n">test_targets</span>
<span class="n">err</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">err</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="n">acc</span> <span class="o">=</span> <span class="nb">float</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">test_targets</span><span class="p">)</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">(</span><span class="n">err</span><span class="p">))</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">test_targets</span><span class="p">))</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Accuracy: </span><span class="si">%</span><span class="s">f"</span> <span class="o">%</span> <span class="n">acc</span><span class="p">)</span></code></pre></figure>

<p>When running the script, you should see the following output:</p>

<figure class="highlight"><pre><code class="language-bash" data-lang="bash"><span class="gp">$ </span>python perceptron.py
Accuracy: 1.000000</code></pre></figure>

<p>Because the data is linearly separable, the algorithm found the optimal values for €\theta€, and is now able to correctly classify all 50 test samples. Had the data not been linearly separable, it would have been a <em>whole</em> other story.</p>

<p>In the <a href="http://sigmoidprime.com/post/how-to-build-a-neural-network-pt-2">next post</a>, we will cover some slightly more complex terrain in order to see how we can get closer to modelling data that is not linearly separable.</p>

        </article>
        <br /><br />
        <footer>
          <div class="inner-footer">
            <p><b>Questions? Comments? Corrections?</b></p>
            <br />
            <p>Whatever it may be, don't hesitate to let me know. You can get in touch on <a href="http://twitter.com/wster" target="_blank">Twitter</a> or via <a href="mailto:august.wester@gmail.com">email</a>.</p>
          </div>
        </footer>
      </div>
    </main>
    <script type="text/javascript">
      var config = [{left:"€€", right:"€€", display:true}, {left: "€", right:"€", display:false}];
      renderMathInElement(document.body, {delimiters: config});
    </script>
    
    <script>
      (function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,"script","https://www.google-analytics.com/analytics.js","ga");
      ga("create", "UA-89251189-1", "auto");
      ga("send", "pageview");
    </script>
    
  </body>
</html>
