<!doctype html> <html lang="en"> <head> <meta charset="utf-8"> <title>How to Build (and Understand) a Neural Network Pt. 2: Logistic Regression</title> <meta name="description" content="A look at logistic regression in preparation for building a neural network."> <meta name="twitter:card" content="summary_large_image"> <meta name="twitter:creator" content="@augustwester"> <meta name="twitter:title" content="How to Build (and Understand) a Neural Network Pt. 2: Logistic Regression"> <meta name="twitter:image" content="http://sigmoidprime.com//assets/posts/2/thumb.png"> <link rel="stylesheet" href="/css/style.css"> <link rel="stylesheet" href="/libs/highlight/styles/github.min.css"> <link rel="stylesheet" href="/libs/katex/katex.min.css"> <link rel="stylesheet" href="/libs/c3/c3.min.css"> <link rel="apple-touch-icon-precomposed" sizes="57x57" href="/assets/favicons/apple-touch-icon-57x57.png"> <link rel="apple-touch-icon-precomposed" sizes="114x114" href="/assets/favicons/apple-touch-icon-114x114.png"> <link rel="apple-touch-icon-precomposed" sizes="72x72" href="/assets/favicons/apple-touch-icon-72x72.png"> <link rel="apple-touch-icon-precomposed" sizes="144x144" href="/assets/favicons/apple-touch-icon-144x144.png"> <link rel="apple-touch-icon-precomposed" sizes="60x60" href="/assets/favicons/apple-touch-icon-60x60.png"> <link rel="apple-touch-icon-precomposed" sizes="120x120" href="/assets/favicons/apple-touch-icon-120x120.png"> <link rel="apple-touch-icon-precomposed" sizes="76x76" href="/assets/favicons/apple-touch-icon-76x76.png"> <link rel="apple-touch-icon-precomposed" sizes="152x152" href="/assets/favicons/apple-touch-icon-152x152.png"> <link rel="icon" type="image/png" href="/assets/favicons/favicon-196x196.png" sizes="196x196"> <link rel="icon" type="image/png" href="/assets/favicons/favicon-96x96.png" sizes="96x96"> <link rel="icon" type="image/png" href="/assets/favicons/favicon-32x32.png" sizes="32x32"> <link rel="icon" type="image/png" href="/assets/favicons/favicon-16x16.png" sizes="16x16"> <link rel="icon" type="image/png" href="/assets/favicons/favicon-128.png" sizes="128x128"> <script src="/libs/highlight/highlight.pack.js"></script> <script src="/libs/katex/katex.min.js"></script> <script src="/libs/katex/contrib/auto-render.js"></script> <script src="/libs/d3/d3.v3.min.js"></script> <script src="/libs/function-plot/function-plot.js"></script> <script src="/libs/c3/c3.min.js"></script> <script>hljs.initHighlightingOnLoad();</script> </head> <body> <div id="sidebar"> <div class="picture"></div> <p class="hi">Hi. I'm <span class="highlight">August</span>.</p> <p class="bio">I hold an MSc in computer science from the IT University in <span class="highlight">Copenhagen</span> where I specialized in <span class="highlight">machine learning</span>.</p> <p class="bio">During my studies, I focused primarily on the topics of <span class="highlight">generative models</span>, <span class="highlight">adversarial robustness</span>, and <span class="highlight">causal inference</span>.</p> <p class="bio">I'm driven by the idea of one day creating software with <span class="highlight">creativity</span> and <span class="highlight">personhood</span>.</p> <div class="social-media-container"> <div class="social-media-icons"> <a href="https://twitter.com/augustwester"><img src="/assets/icons/twitter.svg" style="width:35px;height:28px;"></a> <a href="https://github.com/augustwester"><img src="/assets/icons/github.svg" style="width:28px;height:28px;"></a> <a href="mailto:august.wester@gmail.com"><img src="/assets/icons/email.svg" style="width:28px;height:28px;"></a> </div> </div> </div> <div id="overlay"> <div id="content"> <header class="top-header"> <div id="hamburger" onclick="toggleSidebar()"> <div class="sidebar-icon-top"></div> <div class="sidebar-icon-bottom"></div> </div> <div class="inner-header"> <div class="logo-container"> <a href="/"><span class="logo">sigmoid<span class="prime">′</span></span></a> <span class="tagline">a machine learning blog</span> </div> </div> </header> <main style="margin-top:80px;"> <div class="article-container "> <article> <header> <h1 class="post-title">How to Build (and Understand) a Neural Network Pt. 2: Logistic Regression</h1> </header> <div class="date-ct"> <span class="date-span"> <p>16 January 2017</p> </span> <div style="clear:both"></div> </div> <p>In the <a href="http://sigmoidprime.com/post/how-to-build-a-neural-network-pt-1/">previous post</a>, we saw how the perceptron algorithm automatically discovered how to distinguish data points belonging to two different classes. This time, we will explore the ideas behind another algorithm — <strong>logistic regression</strong> — to see how and why it plays a central role in many neural network architectures. We will also demonstrate how it can be used to model slightly more complex and interesting data than the Iris dataset.</p> <h2 id="predicting-university-admissions">Predicting university admissions</h2> <p>For this example, I have taken the liberty of using a dataset offered in Andrew Ng’s <em>fantastic</em> <a href="https://www.coursera.org/learn/machine-learning">Coursera course on machine learning</a>. (If you are reading this blog, I can’t recommend the course enough.) Like the Iris dataset, this one is split into samples of two classes: Admitted and Not Admitted to a university. Each sample only contains two features; namely the score on two different exams. When you plot the samples, they look like this:</p> <div id="university-admissions" class="scatter-plot"></div> <script type="text/javascript" src="/js/university-admissions.js"></script> <p>This dataset is a little more complex than the Iris dataset in that it cannot be perfectly separated by a straight line. In fact, if we wanted to separate the two classes at 100% accuracy, it would require a very complex decision boundary similar to this one:</p> <p><img src="/assets/posts/2/complex-decision-boundary.png" width="800" alt="A complex decision boundary" /></p> <p>To achieve this kind of decision boundary would be marvelous, right? Well; actually it wouldn’t. Decision boundaries like this are a prototypical example of <strong>overfitting</strong>. Overfitting means that our model has adjusted itself too much to our data, and is therefore unlikely to perform well when asked to classify samples it has never seen before. Instead, what we want is a decision boundary that follows the principle of <a href="https://en.wikipedia.org/wiki/Occam's_razor">Occam’s Razor</a>: It needs to define the boundary according to the simplest overall trends in the data by disregarding the fluctuations of random noise.</p> <p>So, however counterintuitive it may seem at first, we don’t want overfitting. However, a simple linear (or slightly curved) decision boundary would also inevitably entail some level of uncertainty about our classification. Wouldn’t it be better if we could estimate the <em>probability</em> of an applicant being admitted rather than a black and white binary prediction?</p> <p>This is what separates <em>regression</em> from <em>classification</em>. When we do classification, we <em>predict</em> that some sample $x^{(i)}$ belongs to some class $y^{(i)}$. Regression, on the other hand, deals with <em>estimating</em> some real number value related to $x^{(i)}$. One example of regression would be if we tried to estimate tomorrow’s value of the S&amp;P 500. Similarly, trying to estimate the probability that an applicant will be admitted to a university is also a regression problem.</p> <h2 id="the-sigmoid-function">The sigmoid function</h2> <p>The logistic function — in machine learning circles better known as the “sigmoid” function — is a simple mathematical function that takes an S-like shape when you plot it on a graph:</p> <div id="quad" class="plot"></div> <script type="text/javascript">functionPlot({target:"#quad",xAxis:{domain:[-7,7]},yAxis:{domain:[0,1]},grid:true,disableZoom:true,width:500,height:300,data:[{fn:"1/(1+exp(-x))"}]})</script> <p>The function itself — which we will denote as $\sigma$ — can be expressed mathematically as:</p> <p>€€ \sigma(z) = \frac{1}{1 + \exp(-z)} €€</p> <p class="subtext">Can you see from the equation why the function looks the way it does?</p> <p>Besides its pretty shape, there is one thing in particular to note about the sigmoid function: No matter how big or small the value of $z$ becomes, the function always outputs a real number between 0 and 1. This is handy, since it enables us to think of $\sigma$ as outputting a probability, where $\sigma = 0.5$ when $z = 0$, and $\sigma = 1$ as $z\rightarrow\infty$. The output of $\sigma$ will thus be our estimate of the probability that an applicant will be admitted to the university.</p> <p><img src="/assets/posts/2/lr-db.png" width="800px" alt="A gradient of confidence on either side of a decision boundary" /></p> <p>This is a contour plot showing the “decision boundary” of a model that has been trained on our dataset with logistic regression. Even though the boundary is still linear, it has now become more nuanced with the dark blue region indicating near certainty that $x^{(i)}$ is admitted ($\hat{y}^{(i)}\approx1$), and the dark red region indicating the opposite ($\hat{y}^{(i)}\approx0$). This is pretty nice since it reveals when our model is faced with uncertainty.</p> <h2 id="defining-our-model">Defining our model</h2> <p>In Pt. 1, we saw how the perceptron model was a linear function of the form</p> <p>€€ \theta_1x_1 + \theta_2x_2 \cdots +\theta_nx_n + b €€</p> <p>where $\theta$ was an $n$-dimensional vector of weights, and $x$ was an $n$-dimensional vector of features. We also saw how we could simplify this expression by adding $b$ as an element $\theta_0$ to the vector $\theta$, and by ensuring that its corresponding element in the vector $x$ was always 1:</p> <p>€€ \theta \cdot x = \begin{Bmatrix}\theta_0 \cr \theta_1 \cr \theta_2 \cr \vdots \cr \theta_n\end{Bmatrix} \cdot \begin{Bmatrix}1 \cr x_1 \cr x_2\cr \vdots \cr x_n \end{Bmatrix}= \theta_0 + \theta_1x_1 + \cdots + \theta_nx_n €€</p> <p>In logistic regression, we do exactly the same. However, instead of stopping here, we feed the result of the dot product between $\theta$ and $x$ to the sigmoid function $\sigma$. Concretely, this means that given a vector $x$ containing an applicant’s exam-scores, the probability that they will be admitted to the university is calculated as:</p> <p>€€ \sigma(\theta \cdot x) = \frac{1}{1+\exp(-(\theta \cdot x))} €€</p> <p>The fact that we run the input data through the same linear function as the perceptron algorithm is the reason why the decision boundary remains linear. The nuance of the contour plot above is simply the result of passing the output of our linear function as a parameter to $\sigma$.</p> <p>When we first initialize our logistic regression model, our parameters $\theta$ will again have random values between 0 and 1. As a result, the probabilities outputted by $\sigma$ will be way off the intended values in the beginning. To improve our parameters, we need a learning algorithm.</p> <h2 id="quantifying-errors-using-loss-functions">Quantifying errors using loss functions</h2> <p>The learning algorithm for logistic regression is slightly more advanced than what we saw with the perceptron in the previous post. To understand how it works, we need to familiarize ourselves with the idea of a <strong>loss function</strong>.</p> <p>A loss function is a mathematical function that calculates the deviation of a prediction from the target value. Let’s see what this means by looking at the loss function for logistic regression:</p> <p>€€ \frac{1}{m}\sum\limits_{i=1}^{m}-y^{(i)} \log(\hat{y}^{(i)}) - (1-y^{(i)}) \log(1-\hat{y}^{(i)}) €€</p> <p class="subtext">$(i)$ is the index of sample $i$, $y^{(i)}$ is the corresponding target value, and $\hat{y}^{(i)}$ is our probability estimate. $m$ is the total number of samples. Multiplying by $\frac{1}{m}$ gives us the mean loss.</p> <p>Suppose we take a sample $x^{(i)}$ from our dataset with a target value $y^{(i)}$ of 1 (Admitted). When we begin training our model, it estimates the probability of $x^{(i)}$ being admitted at, say, 0.36 (a pretty bad estimate). Plugging these values into the loss function, we get:</p> <p>€€ -1 \cdot \log(0.36) - 0 \cdot \log(1-0.36) €€</p> <p class="subtext">I have omitted the fraction and the summation, since we are only looking at the error of a single sample.</p> <p>Because $y^{(i)}=1$, the second term in the expression falls away, and all we are left with is:</p> <p>€€ -1 \cdot \log(0.36) \approx 0.44 €€</p> <p>Now suppose we take another sample from our set; this time with a target value of 0. For simplicity’s sake, let’s assume that our probability estimate for this sample is 0.36 as well.</p> <p>€€ 0 \cdot \log(0.36) - 1 \cdot \log(1-0.36) €€</p> <p>This time, the first term falls away, leaving us with:</p> <p>€€ -1 \cdot \log(1-0.36) \approx 0.19 €€</p> <p>Notice how the loss was higher when $y^{(i)}=1$. This is exactly what we want, since our estimate of 0.36 is farther from 1 than from 0.</p> <p>We know for a fact that each of our samples $x^{(i)}$ has a target value $y^{(i)}$ of either 0 or 1. It is never in between. This is nice, because it tells us that the loss for each sample can only be expressed as either $-1 \cdot \log(\hat{y}^{(i)})$ or $-1 \cdot \log(1-\hat{y}^{(i)})$. Let’s plot the two functions:</p> <div id="log1" class="plot"></div> <script type="text/javascript">functionPlot({target:"#log1",xAxis:{domain:[0,1]},yAxis:{domain:[0,5]},grid:true,disableZoom:true,width:500,height:300,data:[{fn:"-1*log(x)",derivative:{fn:"-1/x", updateOnMouseMove:true}}]})</script> <p class="subtext">$-1 \cdot \log(\hat{y}^{(i)})$</p> <div id="log2" class="plot"></div> <script type="text/javascript">functionPlot({target:"#log2",xAxis:{domain:[0,1]},yAxis:{domain:[0,5]},grid:true,disableZoom:true,width:500,height:300,data:[{fn:"-1*log(1-x)",derivative:{fn:"1/(1-x)", updateOnMouseMove:true}}]})</script> <p class="subtext">$-1 \cdot \log(1-\hat{y}^{(i)})$</p> <p>Two very useful features are evident from these plots:</p> <ol> <li>Both functions are continuous and therefore differentiable.</li> <li>The functions are 0 when the estimated probability $\hat{y}^{(i)}$ is equal to the target value $y^{(i)}$, and they both approach infinity as $\hat{y}^{(i)}$ moves in the opposite direction.</li> </ol> <p>To see why this is useful, we need to talk about a beautiful and extremely powerful idea known as <strong>gradient descent</strong>.</p> <h2 id="minimizing-error-with-gradient-descent">Minimizing error with gradient descent</h2> <p>We just saw how we could quantify the error of our model’s probability estimates by using a loss function. The beauty of a loss function is that it can be effectively minimized with the help of some relatively straightforward calculus. (If your calculus is shaky, I suggest you take a <a href="https://www.youtube.com/watch?v=EKvHQc3QEow&amp;list=PL19E79A0638C8D449">crash course with Sal</a> until you are comfortable with derivates — it is really not that bad.)</p> <p>Recall that we calculate the probability of a sample $x^{(i)}$ being admitted as:</p> <p>€€ \sigma(\theta \cdot x^{(i)}) = \frac{1}{1+\exp(-\theta \cdot x^{(i)})} €€</p> <p>This means that $\sigma(\theta \cdot x^{(i)})=\hat{y}^{(i)}$. For clarity, let’s try to represent our complicated-looking-but-really-very-simple loss function by referring to our probability estimate this way.</p> <p>€€ \frac{1}{m}\sum\limits_{i=1}^{m}-y^{(i)} \log(\hat{y}^{(i)}) - (1-y^{(i)}) \log(1-\hat{y}^{(i)}) €€ €€ \downarrow €€ €€ \frac{1}{m}\sum\limits_{i=1}^{m}-y^{(i)} \log(\sigma(\theta \cdot x^{(i)})) - (1-y^{(i)}) \log(1-\sigma(\theta \cdot x^{(i)})) €€</p> <p>In the previous section, I mentioned that the loss function above is differentiable. I did not mention that the sigmoid function is as well. This is significant because — and this is where it gets cool — by having all the layers of our algorithm be differentiable, we can calculate the derivates of the loss function with respect to our parameters $\theta$! Let that sink in for a while.</p> <p>What this means is that we can measure <em>exactly</em> how a change in our parameters $\theta$ affects a change in our loss function. When you think about it, this is unbelievably cool. In theory, you could filter $x^{(i)}$ through thousands of layers of manipulations, and as long as they are all differentiable, you can calculate how each individual one of them is affecting the final loss (and thus how to change them in order to improve your model). In fact, this is <em>exactly</em> how any neural network improves itself when exposed to new data. We will explore this technique in more detail in Pt 4.</p> <p>The partial derivative of our loss function (which I will henceforth refer to as $C$) w.r.t. a single parameter $\theta_j$ looks like this:</p> <p>€€ \frac{\partial C}{\partial \theta_j}=(\sigma(\theta \cdot x^{(i)})-y^{(i)})x_j^{(i)} €€</p> <p class="subtext">$j$ refers to the $j$th feature of sample $i$. If you are curious about the steps behind the derivation, check out the top-rated answer <a href="http://math.stackexchange.com/questions/477207/derivative-of-loss-function-for-logistic-regression?newreg=193313544a574729babc17a42602a428">here</a>.</p> <p>A better way of writing this is to use the gradient expression:</p> <p>€€ \nabla_\theta C = (\sigma(\theta \cdot x^{(i)})-y^{(i)})x^{(i)} €€</p> <p class="subtext">Note that $(\sigma(\theta \cdot x^{(i)})-y^{(i)})$ is a scalar, while $x^{(i)}$ is a vector.</p> <p>A gradient (denoted by the symbol $\nabla$) is no more than a collection of partial derivatives. In this particular example, we have three parameters: the bias $\theta_0$ and the weights $\theta_1$ and $\theta_2$. Since we have three parameters and want to know how each one of them influences the loss $C$, we end up with three different derivatives. The gradient will therefore be a three-dimensional vector containing the derivatives for our three parameters.</p> <p>You probably remember from high school that a positive derivative means that we are moving “uphill” while a negative derivative means that we are moving “downhill”. Thus, if we get a positive derivative for one of our parameters, we want the value of that particular parameter to move in the opposite direction (since moving uphill is equivalent to increasing our loss).</p> <p><img src="/assets/posts/2/gradient-descent.png" width="480" alt="Convex loss function" /></p> <p class="subtext">A contrived example showing how we want $\theta$ to move in the direction that minimizes the loss. Here, $\theta$ would be a two-dimensional vector.</p> <p>But hold on. The above definition of our gradient only deals with a single sample! We <em>could</em> choose to “walk downhill” with the help of this gradient alone, but by doing that, we would only be walking down the loss function <em>for this particular sample</em>. To get a gradient that will improve our parameters with respect to <em>all</em> $n$ samples, we have to find the mean gradient like so:</p> <p>€€ \nabla_\theta C = \frac{1}{m}\sum\limits_{i=1}^{m}(\sigma(\theta \cdot x^{(i)})-y^{(i)})x^{(i)} €€</p> <p>That is more like it. When we perform this calculation, we get a gradient containing the mean — or distillation if you will — of all of the partial derivatives w.r.t. $\theta$ in our training set. One way to think of this is that each derivative gets to vote on which way is downhill. When we use the mean of all the votes, we move in the direction that causes a drop in the loss for the majority of our samples.</p> <p>As mentioned, if the derivative for a particular parameter $\theta_j$ is positive, we want to decrease the value of $\theta_j$. Likewise, if $\theta_j$ has a negative derivative, we want to increase the value of $\theta_j$. For now, the increments by which we change $\theta_j$’s current value will simply be the same as the value of the derivatives. The following update rule describes exactly this procedure.</p> <p>€€ \theta := \theta -\nabla_\theta C €€</p> <p>Because of the minus sign, negative derivatives will cause the value of $\theta_j$ to increase, and positive values will cause $\theta_j$ to decrease. Exactly what we want! If we do this for enough iterations (aka. <strong>epochs</strong>), our algorithm should converge on the parameters that cause the total loss to be as small as possible. Let’s see if this works by applying what we have learned in code.</p> <h2 id="creating-a-logistic-regression-model-in-python">Creating a logistic regression model in Python</h2> <p>To create our logistic regression model, we will again be using <a href="http://www.numpy.org/">NumPy</a> to handle all of our matrix and vector operations as well as <a href="http://matplotlib.org/">matplotlib</a> to visualize what is going on. Both of these can be installed by running <code class="highlighter-rouge">pip3 install numpy</code> and <code class="highlighter-rouge">pip3 install matplotlib</code> (or simply <code class="highlighter-rouge">pip</code> if you prefer to use Python 2) on the command line. Besides NumPy and matplotlib, make sure that you also download the dataset <a href="/assets/posts/2/exam_scores.zip">here</a>. Place the dataset in a dedicated folder for the project, and create a new Python file called <code class="highlighter-rouge">logistic_regression.py</code> in the same folder.</p> <p>First, we will set up a <code class="highlighter-rouge">LogisticRegression</code> class. The <code class="highlighter-rouge">init</code> method will initialize an array <code class="highlighter-rouge">self.theta</code> containing our three random parameters.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="kn">import</span> <span class="nn">numpy</span> <span class="kn">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="kn">as</span> <span class="nn">plt</span>

<span class="k">class</span> <span class="nc">LogisticRegression</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">LogisticRegression</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">random</span><span class="o">.</span><span class="n">rand</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">fit</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">epochs</span><span class="p">):</span>
        <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
        <span class="n">weighted_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
        <span class="n">probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">weighted_input</span><span class="p">)</span>

        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">epochs</span><span class="p">):</span>
            <span class="n">gradients</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">loss_prime</span><span class="p">(</span><span class="n">probs</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">theta</span> <span class="o">-=</span> <span class="n">gradients</span>
            <span class="n">weighted_input</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)</span>
            <span class="n">probs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">weighted_input</span><span class="p">)</span>

        <span class="k">print</span><span class="p">(</span><span class="s">"Training finished"</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">standardize</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
        <span class="n">X_std</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">shape</span><span class="p">(</span><span class="n">X</span><span class="p">))</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">X</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span> <span class="c"># no need to standardize the x_0 column</span>
            <span class="n">X_std</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">-</span> <span class="n">np</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]))</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">std</span><span class="p">(</span><span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">X_std</span></code></pre></figure> <p>We haven’t yet implemented all of the referenced methods, but if you analyze <code class="highlighter-rouge">fit</code>, you will see that — except for the <code class="highlighter-rouge">standardize</code> part — we have covered the theory behind everything that is happening. So, before we proceed, what does <code class="highlighter-rouge">standardize</code> do?</p> <p><a href="http://sebastianraschka.com/Articles/2014_about_feature_scaling.html#about-standardization">Standardization</a> is done using the following formula, and forces the features of a dataset to follow a normal distribution with mean $\mu=0$ and standard deviation $\sigma=1$ (not to be confused with the sigmoid function, which we also denoted as $\sigma$).</p> <p>€€ \frac{x_j^{(i)}-\mu}{\sigma} €€</p> <p>Performing this trick on our particular dataset squishes the features of our first sample from around <code class="highlighter-rouge">34.62</code> and <code class="highlighter-rouge">78.02</code> down to about <code class="highlighter-rouge">-1.60</code> and <code class="highlighter-rouge">0.63</code> respectively. We need to do this, because the dot product $\theta \cdot x^{(i)}$ has to be pretty small in order to avoid <strong>saturation</strong>. Saturation happens when we plug large values into the sigmoid function. This returns a number extremely close to 1, and we thus run the risk of numerical overflow and <a href="https://www.quora.com/What-is-the-vanishing-gradient-problem/answer/Nikhil-Garg?srid=06OE">vanishing gradients</a>. To avoid this, we use standardization to scale our features down to have zero-mean while still maintaining the ratios between the features.</p> <p>We will now add the partial derivative of the loss function with respect to our parameters:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">loss_prime</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
    <span class="n">gradients</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">empty</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">size</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">))</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">)):</span>
        <span class="n">gradients</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">probs</span><span class="p">))</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="nb">sum</span><span class="p">((</span><span class="n">probs</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span> <span class="o">*</span> <span class="n">X</span><span class="p">[:,</span> <span class="n">i</span><span class="p">])</span>
    <span class="k">return</span> <span class="n">gradients</span></code></pre></figure> <p>This method outputs our gradient; an array with the same dimensions as <code class="highlighter-rouge">self.theta</code> containing one derivative per parameter. If you inspect the calculation, you will see that it is exactly the same as the gradient formula we talked about a few moments ago.</p> <p>At this point, every piece of the puzzle is in place for the algorithm to train a working model. To see the fruits of our labor, though, we need to implement one last method:</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="k">def</span> <span class="nf">estimate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">X</span><span class="p">):</span>
    <span class="n">X</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">standardize</span><span class="p">(</span><span class="n">X</span><span class="p">)</span>
    <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">dot</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">theta</span><span class="p">))</span></code></pre></figure> <p><code class="highlighter-rouge">estimate</code> will simply take a matrix (or <em>2D array</em> in NumPy-speak) of samples, and return the model’s estimated probabilities of admission for each sample. We will use this method to generate a contour plot like the one we saw earlier.</p> <p>Alright! Our <code class="highlighter-rouge">LogisticRegression</code> class is done; now we need to import the dataset, train the model, and make a contour plot like the one we saw earlier.</p> <figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="s">"exam_scores.txt"</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">","</span><span class="p">)</span> <span class="c"># importing the data</span>
<span class="n">data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">data</span><span class="p">),</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">data</span><span class="p">]</span> <span class="c"># making sure that x_0=1 for all samples</span>

<span class="n">X</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="mi">3</span><span class="p">]</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span>

<span class="n">lr</span> <span class="o">=</span> <span class="n">LogisticRegression</span><span class="p">()</span>
<span class="n">lr</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="mi">100</span><span class="p">)</span> <span class="c"># 100 epochs</span>

<span class="c"># Creating a set of all possible exam scores between 20 and 110 in increments</span>
<span class="c"># of .5. Feeding this to our trained model will color our contour plot.</span>
<span class="n">xx</span><span class="p">,</span> <span class="n">yy</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">mgrid</span><span class="p">[</span><span class="mi">20</span><span class="p">:</span><span class="mi">110</span><span class="p">:</span><span class="o">.</span><span class="mi">5</span><span class="p">,</span> <span class="mi">20</span><span class="p">:</span><span class="mi">110</span><span class="p">:</span><span class="o">.</span><span class="mi">5</span><span class="p">]</span>
<span class="n">comb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">xx</span><span class="o">.</span><span class="n">ravel</span><span class="p">(),</span> <span class="n">yy</span><span class="o">.</span><span class="n">ravel</span><span class="p">()]</span>
<span class="n">comb</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">c_</span><span class="p">[</span><span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">comb</span><span class="p">),</span> <span class="mi">1</span><span class="p">)),</span> <span class="n">comb</span><span class="p">]</span>
<span class="n">probs</span> <span class="o">=</span> <span class="n">lr</span><span class="o">.</span><span class="n">estimate</span><span class="p">(</span><span class="n">comb</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">xx</span><span class="o">.</span><span class="n">shape</span><span class="p">)</span>

<span class="n">f</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">12</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
<span class="n">contour</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">contourf</span><span class="p">(</span><span class="n">xx</span><span class="p">,</span> <span class="n">yy</span><span class="p">,</span> <span class="n">probs</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="s">"RdYlBu"</span><span class="p">,</span> <span class="n">vmin</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">vmax</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>

<span class="n">a</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">1</span><span class="p">]</span> <span class="c"># admitted samples</span>
<span class="n">na</span> <span class="o">=</span> <span class="n">X</span><span class="p">[</span><span class="n">data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span> <span class="c"># non-admitted samples</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">a</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">a</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="mf">28.0</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mf">159.0</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mf">251.0</span><span class="o">/</span><span class="mi">255</span><span class="p">))</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">na</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">na</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">c</span><span class="o">=</span><span class="p">(</span><span class="mf">252.0</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mf">81.0</span><span class="o">/</span><span class="mi">255</span><span class="p">,</span> <span class="mf">80.0</span><span class="o">/</span><span class="mi">255</span><span class="p">))</span>

<span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span></code></pre></figure> <p>If you run this, you should see a contour plot exactly like the one I showed in the beginning.</p> <p>Pat yourself on the back if you have followed along this far. You are now very well suited to tackle the final problem in this series: building a neural network.</p> </article> <br /><br /> <footer> <div class="inner-footer"> <p><b>Questions? Comments? Corrections?</b></p> <br /> <p>Whatever it may be, don't hesitate to let me know. You can get in touch on <a href="http://twitter.com/augustwester" target="_blank">Twitter</a> or via <a href="mailto:august.wester@gmail.com">email</a>.</p> </div> </footer> </div> </main> </div> </div> <script> function toggleSidebar() { let content = document.getElementById("content"); let sidebar = document.getElementById("sidebar"); let overlay = document.getElementById("overlay"); let hamburger = document.getElementById("hamburger"); if (content.classList.contains("translate-right")) { content.classList.remove("translate-right"); sidebar.classList.remove("translate-right"); content.style.pointerEvents = "auto"; overlay.style.cursor = "auto"; document.body.style.overflow = "visible"; overlay.onmouseup = undefined; } else { content.classList.add("translate-right"); content.style.pointerEvents = "none"; overlay.style.cursor = "pointer"; sidebar.classList.add("translate-right"); content.style.pointerEvents = "none"; document.body.style.overflow = "hidden"; overlay.onmouseup = function() { toggleSidebar(); } } } </script> <script type="text/javascript"> var config = [{left:"€€", right:"€€", display:true}, {left: "$", right:"$", display:false}]; renderMathInElement(document.body, {delimiters: config}); </script> <script> (function(i,s,o,g,r,a,m){i["GoogleAnalyticsObject"]=r;i[r]=i[r]||function(){ (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o), m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m) })(window,document,"script","https://www.google-analytics.com/analytics.js","ga"); ga("create", "UA-89251189-1", "auto"); ga("send", "pageview"); </script> </body> </html>
